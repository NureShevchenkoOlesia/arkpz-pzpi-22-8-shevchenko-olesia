Міністерство освіти і науки України  Харківський національний університет радіоелектроніки       Лабораторна робота №2 Дисципліна: «Архітектура програмного забезпечення»       Виконала: Перевірив: ст. гр. ПЗПІ-22-8 ст. викл. каф. ПІ Шевченко О. О. Сокорчук І. П.      Харків 2024 ВСТУП  	Метою лабораторної роботи є розробка серверної частини проєкту за темою: «Програмна система для контролю доступу до лабораторій».      Хід даної роботи має такий вигляд: 1. Моделювання програмної системи;2. Проектування бази даних програмної системи;3. Побудова серверних компонентів системи, специфікація API.4. Додатки.
1 МОДЕЛЮВАННЯ ПРОГРАМНОЇ СИСТЕМИ               Серверна частина системи буде реалізована на платформі Flask (Python Web Framework). Відповідно, мовою програмування обрано Python. Для зберігання даних буде використовуватись СУБД PostgreSQL. Для взаємодії з СУБД буде використовуватися ORM SQLAlchemy (з підтримкою Flask-SQLAlchemy).      Структура проєкту включає: маршрути, які відповідають за прийом HTTP-запитів від клієнтів, передачу даних на рівень сервісів та обробку відповіді; сервіси, що забезпечують обробку бізнес-логіки, виконання основних операцій; моделі: сутності, що відповідають таблицям бази даних.1.1 Розробка UML-діаграми прецедентів     UML-діаграма прецедентів необхідна для ілюстрації сценаріїв взаємодії користувачів із системою. Користувачами даної системи є працівник лабораторії, адміністратор та IoT-пристрій.      Основними потребами користувача системи є:       – можливість подачі запиту на доступ до лабораторії;      – вхід до лабораторії після схвалення запиту;      – отримання сповіщень про статус запиту на доступ;      – можливість перегляду історії своїх запитів.      Основними потребами адміністратора є:      – можливість додавати, редагувати, видаляти користувачів;      – можливість додавати, редагувати, видаляти лабораторії;      – можливість додавати та видаляти сенсори доступу;      – можливість генерувати звіти про події доступу.      Основними потребами IoT-пристрою є:      – перевірка користувача після схвалення запиту на доступ;      – відстеження часу перевірки. UML-діаграму наведено на рисунку 1.     Рисунок 1 – UML-діаграма прецедентів     1.2  Розробка ER-моделі даних     ER-модель даних складається з 6 сутностей:       – «Користувач» з атрибутами: імʼя, прізвище, адреса електронної пошти, пароль для авторизації, посада, рівень доступу;      – «Лабораторія» з атрибутами: назва, вимоги доступу (мінімальний рівень доступу користувача), ідентифікатор статусу;      – «Подія доступу» з атрибутами: ідентифікатор користувача, ідентифікатор лабораторії, час створення, статус («Схвалено»/ «Відхилено»/ «Обробляється»).      – «Сенсор» з атрибутами: ідентифікатор лабораторії, ідентифікатор користувача, дані для доступу (індивідуальні біометричні дані користувача), час останнього використання, статус («Активний»/«Неактивний»);      – «Посада користувача» з атрибутом тип посади (механік, голова лабораторії, хімік та ін.);      – «Статус лабораторії» з атрибутом тип статусу («Доступна»/ «Недоступна»).     Наявні наступні зв’язки між сутностями:       – Користувач має звʼязок «один до багатьох» з подією доступу, оскільки користувач може отримати доступ до багатьох лабораторій багато разів, але кожна подія доступу відповідає лише одному користувачу.      – Лабораторія має звʼязок «один до багатьох» з подією доступу, оскільки лабораторія може бути доступна багатьом користувачам, але кожна подія доступу відповідає лише одній лабораторії.       – Лабораторія має звʼязок «один до багатьох» з сенсором, оскільки ідентифікація користувача, який намагається отримати доступ, може відбуватися за допомогою багатьох сенсорів, але один сенсор може ідентифікувати користувача лише для однієї лабораторії.       – Сенсор має звʼязок «один до одного» з користувачем, оскільки один сенсор може бути використаний для ідентифікації лише одного користувача.      – Лабораторія має зв’язок «один до одного» зі статусом лабораторії, оскільки одна лабораторія може мати лише один актуальний статус.       – Користувач має звʼязок «один до одного» з посадою користувача, оскільки одному працівнику лабораторії відповідає лише одна посада.     ER-модель даних наведено на рисунку 2.Рисунок 2 – ER-діаграма даних
2 ПРОЕКТУВАННЯ БАЗИ ДАНИХ     Для створення бази даних використано СУБД PostgreSQL. Таблиці реалізовано відповідно до ER-діаграми даних, налаштовано зовнішні ключі для збереження звʼязків між сутностями. Скрипт на створення таблиць БД наведено в додатку А.     На рисунку 3 продемонстровано діаграму структури розробленої БД для даної програмної системи.     Рисунок 3 – Схема розробленої бази даних     Основні функції (CRUD) реалізовані за допомогою SQLAlchemy. Налаштовано взаємодію з усіма необхідними таблицями БД («UserOccupations» та «LabStatuses» є допоміжними таблицями, і, відповідно, не потребують окремої взаємодії). Тестування IoT-пристрою та реалізації отримання доступу до лабораторій заплановано на лабораторну роботу № 4.
3 ПОБУДОВА СЕРВЕРНИХ КОМПОНЕНТІВ СИСТЕМИ, СПЕЦИФІКАЦІЯ РОЗРОБЛЕНОГО API     У розробленій програмній системі серверна частина забезпечує взаємодію між клієнтами та базою даних за допомогою API. Логіка взаємодії організована через маршрути, які обробляють HTTP-запити, передають дані до сервісів і повертають клієнтам результат у форматі JSON. Логіка взаємодії поділяється на два основні рівні: логіка взаємодії з БД – реалізується за допомогою сервісів, які працюють із таблицями бази даних через ORM SQLAlchemy, та логіка взаємодії з клієнтами – забезпечується маршрутами, які приймають запити клієнтів і формують відповіді.      Для роботи з базою даних використовуються сервіси, які містять методи для виконання CRUD-операцій (створення, читання, оновлення, видалення). Сервіси ізольовані від HTTP-запитів і працюють безпосередньо з моделями бази даних. Наприклад, отримання списку всіх лабораторій реалізовано наступним чином: 
# Отримати список усіх лабораторій@labs_bp.route("/", methods=["GET"])@admin_requireddef get_labs():    try:        labs = Lab.query.all()        labs_list = [            {                "id": lab.id,                "title": lab.title,                "access_requirements": lab.access_requirements,                "status_id": lab.status_id,            }            for lab in labs        ]        return jsonify(labs_list), 200    except Exception as e:        return jsonify({"error": "Failed to fetch labs", "details": str(e)}), 500

     Цей метод виконує SQL-запит через ORM SQLAlchemy для отримання всіх записів із таблиці labs. Після цього формується список словників із даними лабораторій, який зручно повертати клієнту.     Логіка взаємодії з клієнтами розроблена таким чином, що маршрути обробляють HTTP-запити, викликаючи відповідні методи сервісів, і формують відповіді для клієнтів. Така реалізація забезпечує чіткий поділ відповідальності: маршрути відповідають за HTTP-запити, сервіси – за бізнес-логіку, а моделі – за доступ до бази. Завдяки цьому легко додавати нові функції, розширювати базу даних або змінювати бізнес-логіку, а кожен рівень системи можна перевіряти окремо.       Використання ORM SQLAlchemy дозволило зосередитися на логіці застосунку, абстрагуючись від написання SQL-запитів, а структура маршрутів з сервісами забезпечила простоту підтримки й розширення системи.      Специфікацію наведено в додатку Б: в таблицях додатка наведено шляхи, методи та описи створених запитів.  
     ВИСНОВКИ               В результаті виконання даної лабораторної роботи було розроблено базу даних для серверної частини «Програмної системи для контролю доступу до лабораторій». Описано прийняті інженерні рішення, розроблено UML та ER діаграми. Функції роботи з базою даних протестовані за допомогою інструменту тестування Postman.      Посилання на відео-захист: https://youtu.be/jAGPgP3N6C4      	 
ДОДАТОК АСкрипт на створення таблиць у БД lab_access_control
-- події доступуCREATE TABLE IF NOT EXISTS public.accessevents(    id integer NOT NULL DEFAULT nextval('accessevents_id_seq'::regclass),    user_id integer,    lab_id integer,    "timestamp" timestamp without time zone NOT NULL,    status character varying(100) COLLATE pg_catalog."default",    reason character varying(255) COLLATE pg_catalog."default",    CONSTRAINT accessevents_pkey PRIMARY KEY (id),    CONSTRAINT accessevents_lab_id_fkey FOREIGN KEY (lab_id)        REFERENCES public.labs (id) MATCH SIMPLE        ON UPDATE NO ACTION        ON DELETE CASCADE,    CONSTRAINT accessevents_user_id_fkey FOREIGN KEY (user_id)        REFERENCES public.users (id) MATCH SIMPLE        ON UPDATE NO ACTION        ON DELETE CASCADE,    CONSTRAINT chk_status CHECK (status::text = ANY (ARRAY['approved'::character varying, 'denied'::character varying, 'pending'::character varying]::text[])))--лабораторіїCREATE TABLE IF NOT EXISTS public.labs(    id integer NOT NULL DEFAULT nextval('labs_id_seq'::regclass),    title character varying(255) COLLATE pg_catalog."default" NOT NULL,    access_requirements integer NOT NULL,    status_id integer,    CONSTRAINT labs_pkey PRIMARY KEY (id),    CONSTRAINT fk_status_id FOREIGN KEY (status_id)        REFERENCES public.labstatuses (id) MATCH SIMPLE        ON UPDATE NO ACTION        ON DELETE NO ACTION)--статуси лабораторійCREATE TABLE IF NOT EXISTS public.labstatuses(    id integer NOT NULL DEFAULT nextval('labstatuses_id_seq'::regclass),    type character varying(255) COLLATE pg_catalog."default" NOT NULL,    CONSTRAINT labstatuses_pkey PRIMARY KEY (id))--сенсориCREATE TABLE IF NOT EXISTS public.sensors(    id integer NOT NULL DEFAULT nextval('sensors_id_seq'::regclass),    lab_id integer,    type character varying(255) COLLATE pg_catalog."default" NOT NULL,    user_id integer,    "timestamp" timestamp without time zone NOT NULL,    access_data character varying(100) COLLATE pg_catalog."default" NOT NULL,    status character varying(50) COLLATE pg_catalog."default" NOT NULL DEFAULT 'active'::character varying,    CONSTRAINT sensors_pkey PRIMARY KEY (id),    CONSTRAINT sensors_lab_id_fkey FOREIGN KEY (lab_id)        REFERENCES public.labs (id) MATCH SIMPLE        ON UPDATE NO ACTION        ON DELETE CASCADE,    CONSTRAINT sensors_user_id_fkey FOREIGN KEY (user_id)        REFERENCES public.users (id) MATCH SIMPLE        ON UPDATE NO ACTION        ON DELETE CASCADE)--посадиCREATE TABLE IF NOT EXISTS public.useroccupations(    id integer NOT NULL DEFAULT nextval('useroccupations_id_seq'::regclass),    type character varying(255) COLLATE pg_catalog."default" NOT NULL,    CONSTRAINT useroccupations_pkey PRIMARY KEY (id))--користувачіCREATE TABLE IF NOT EXISTS public.users(    id integer NOT NULL DEFAULT nextval('users_id_seq'::regclass),    name character varying(255) COLLATE pg_catalog."default" NOT NULL,    surname character varying(255) COLLATE pg_catalog."default" NOT NULL,    email character varying(255) COLLATE pg_catalog."default" NOT NULL,    password character varying(255) COLLATE pg_catalog."default" NOT NULL,    access_level integer NOT NULL,    occupation_id integer,    CONSTRAINT users_pkey PRIMARY KEY (id),    CONSTRAINT users_email_key UNIQUE (email),    CONSTRAINT users_occupation_id_fkey FOREIGN KEY (occupation_id)        REFERENCES public.useroccupations (id) MATCH SIMPLE        ON UPDATE NO ACTION        ON DELETE NO ACTION)
ДОДАТОК БСпецифікація розробленого API Перелік усіх існуючих ендпоінтів з їхнім описом наведено в таблиці 1.     Таблиця 1 – Специфікація системи      «Програмна система для контролю доступу до лабораторій»Ендпоінт Метод Опис /login/ POST Вхід в систему для користувачів/logout/ POST Вихід з системи для користувачів/users/POST Реєстрація нового користувача /users/GET Перелік усіх зареєстрованих користувачів/users/<int:user_id>/PUT Редагування інформації про користувача/users/<int:user_id>/DELETE Видалення користувача Продовження табл. 1 Ендпоінт Метод Опис /labs/ GETПерелік усіх зареєстрованих лабораторій /labs/POSTРеєстрація нової лабораторії /labs/<int:lab_id>/ PUTРедагування інформації про лабораторію/labs/<int:lab_id>/DELETEВидалення лабораторії /labs/<int:lab_id>/update_status/PATCHОновлення статусу лабораторії /access_events/GETСписок усіх створених запитів на доступ /access_events/POSTСтворення нового запиту на доступ/sensors/GETСписок усіх зареєстрованих сенсорів Продовження табл. 1 /sensors/POST Реєстрація нового сенсору /sensors/<int:sensor_id>/DELETE Видалення сенсору       Було складено таблицю зі специфікацією основних ендпоінтів для серверного застосунку.  