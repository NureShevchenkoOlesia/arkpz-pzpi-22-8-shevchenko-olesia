Міністерство освіти і науки України  
Харківський національний університет радіоелектроніки 
 
 
 
 
 
 
Лабораторна робота №2 
Дисципліна: «Архітектура програмного забезпечення» 
 
 
 
 

 
 
Виконала: 
Перевірив: 
ст. гр. ПЗПІ-22-8 
ст. викл. каф. ПІ 
Шевченко О. О. 
Сокорчук І. П. 
 
 
 

 
 
Харків 2024 


ВСТУП 
 

	Метою лабораторної роботи є розробка серверної частини проєкту за темою: «Програмна система для контролю доступу до лабораторій». 
     Хід даної роботи має такий вигляд: 
1. Моделювання програмної системи;
2. Проектування бази даних програмної системи;
3. Побудова серверних компонентів системи, специфікація API.
4. Додатки.


1 МОДЕЛЮВАННЯ ПРОГРАМНОЇ СИСТЕМИ
     
     
     Серверна частина системи буде реалізована на платформі Flask (Python Web Framework). Відповідно, мовою програмування обрано Python. Для зберігання даних буде використовуватись СУБД PostgreSQL. Для взаємодії з СУБД буде використовуватися ORM SQLAlchemy (з підтримкою Flask-SQLAlchemy). 
     Структура проєкту включає: маршрути, які відповідають за прийом HTTP-запитів від клієнтів, передачу даних на рівень сервісів та обробку відповіді; сервіси, що забезпечують обробку бізнес-логіки, виконання основних операцій; моделі: сутності, що відповідають таблицям бази даних.

1.1 Розробка UML-діаграми прецедентів

     UML-діаграма прецедентів необхідна для ілюстрації сценаріїв взаємодії користувачів із системою. Користувачами даної системи є працівник лабораторії, адміністратор та IoT-пристрій. 
     Основними потребами користувача системи є: 
      – можливість подачі запиту на доступ до лабораторії;
      – вхід до лабораторії після схвалення запиту;
      – отримання сповіщень про статус запиту на доступ;
      – можливість перегляду історії своїх запитів.
      Основними потребами адміністратора є:
      – можливість додавати, редагувати, видаляти користувачів;
      – можливість додавати, редагувати, видаляти лабораторії;
      – можливість додавати та видаляти сенсори доступу;
      – можливість генерувати звіти про події доступу.
      Основними потребами IoT-пристрою є:
      – перевірка користувача після схвалення запиту на доступ;
      – відстеження часу перевірки.
 UML-діаграму наведено на рисунку 1.

     Рисунок 1 – UML-діаграма прецедентів
     
1.2  Розробка ER-моделі даних

     ER-модель даних складається з 6 сутностей: 
      – «Користувач» з атрибутами: імʼя, прізвище, адреса електронної пошти, пароль для авторизації, посада, рівень доступу;
      – «Лабораторія» з атрибутами: назва, вимоги доступу (мінімальний рівень доступу користувача), ідентифікатор статусу;
      – «Подія доступу» з атрибутами: ідентифікатор користувача, ідентифікатор лабораторії, час створення, статус («Схвалено»/ «Відхилено»/ «Обробляється»).
      – «Сенсор» з атрибутами: ідентифікатор лабораторії, ідентифікатор користувача, дані для доступу (індивідуальні біометричні дані користувача), час останнього використання, статус («Активний»/«Неактивний»);
      – «Посада користувача» з атрибутом тип посади (механік, голова лабораторії, хімік та ін.);
      – «Статус лабораторії» з атрибутом тип статусу («Доступна»/ «Недоступна»).
     Наявні наступні зв’язки між сутностями: 
      – Користувач має звʼязок «один до багатьох» з подією доступу, оскільки користувач може отримати доступ до багатьох лабораторій багато разів, але кожна подія доступу відповідає лише одному користувачу.
      – Лабораторія має звʼязок «один до багатьох» з подією доступу, оскільки лабораторія може бути доступна багатьом користувачам, але кожна подія доступу відповідає лише одній лабораторії. 
      – Лабораторія має звʼязок «один до багатьох» з сенсором, оскільки ідентифікація користувача, який намагається отримати доступ, може відбуватися за допомогою багатьох сенсорів, але один сенсор може ідентифікувати користувача лише для однієї лабораторії. 
      – Сенсор має звʼязок «один до одного» з користувачем, оскільки один сенсор може бути використаний для ідентифікації лише одного користувача.
      – Лабораторія має зв’язок «один до одного» зі статусом лабораторії, оскільки одна лабораторія може мати лише один актуальний статус. 
      – Користувач має звʼязок «один до одного» з посадою користувача, оскільки одному працівнику лабораторії відповідає лише одна посада.
     ER-модель даних наведено на рисунку 2.

Рисунок 2 – ER-діаграма даних


2 ПРОЕКТУВАННЯ БАЗИ ДАНИХ


     Для створення бази даних використано СУБД PostgreSQL. Таблиці реалізовано відповідно до ER-діаграми даних, налаштовано зовнішні ключі для збереження звʼязків між сутностями. Скрипт на створення таблиць БД наведено в додатку А.
     На рисунку 3 продемонстровано діаграму структури розробленої БД для даної програмної системи.

     Рисунок 3 – Схема розробленої бази даних

     Основні функції (CRUD) реалізовані за допомогою SQLAlchemy. Налаштовано взаємодію з усіма необхідними таблицями БД («UserOccupations» та «LabStatuses» є допоміжними таблицями, і, відповідно, не потребують окремої взаємодії). Тестування IoT-пристрою та реалізації отримання доступу до лабораторій заплановано на лабораторну роботу № 4.


3 ПОБУДОВА СЕРВЕРНИХ КОМПОНЕНТІВ СИСТЕМИ, СПЕЦИФІКАЦІЯ РОЗРОБЛЕНОГО API


     У розробленій програмній системі серверна частина забезпечує взаємодію між клієнтами та базою даних за допомогою API. Логіка взаємодії організована через маршрути, які обробляють HTTP-запити, передають дані до сервісів і повертають клієнтам результат у форматі JSON. Логіка взаємодії поділяється на два основні рівні: логіка взаємодії з БД – реалізується за допомогою сервісів, які працюють із таблицями бази даних через ORM SQLAlchemy, та логіка взаємодії з клієнтами – забезпечується маршрутами, які приймають запити клієнтів і формують відповіді. 
     Для роботи з базою даних використовуються сервіси, які містять методи для виконання CRUD-операцій (створення, читання, оновлення, видалення). Сервіси ізольовані від HTTP-запитів і працюють безпосередньо з моделями бази даних. Наприклад, отримання списку всіх лабораторій реалізовано наступним чином: 


# Отримати список усіх лабораторій
1 @labs_bp.route("/", methods=["GET"])
2 @admin_required
3 def get_labs():
4     try:
5         labs = Lab.query.all()
6         labs_list = [
7             {
8                 "id": lab.id,
9                 "title": lab.title,
10                 "access_requirements": lab.access_requirements,
11                 "status_id": lab.status_id,
12             }
13             for lab in labs
14         ]
15         return jsonify(labs_list), 200
16     except Exception as e:
17         return jsonify({"error": "Failed to fetch labs", "details": str(e)}), 500



     Цей метод виконує SQL-запит через ORM SQLAlchemy для отримання всіх записів із таблиці labs. Після цього формується список словників із даними лабораторій, який зручно повертати клієнту.
     Логіка взаємодії з клієнтами розроблена таким чином, що маршрути обробляють HTTP-запити, викликаючи відповідні методи сервісів, і формують відповіді для клієнтів. Така реалізація забезпечує чіткий поділ відповідальності: маршрути відповідають за HTTP-запити, сервіси – за бізнес-логіку, а моделі – за доступ до бази. Завдяки цьому легко додавати нові функції, розширювати базу даних або змінювати бізнес-логіку, а кожен рівень системи можна перевіряти окремо.  
     Використання ORM SQLAlchemy дозволило зосередитися на логіці застосунку, абстрагуючись від написання SQL-запитів, а структура маршрутів з сервісами забезпечила простоту підтримки й розширення системи. 
     Специфікацію наведено в додатку Б: в таблицях додатка наведено шляхи, методи та описи створених запитів.  


     ВИСНОВКИ
     
     
     В результаті виконання даної лабораторної роботи було розроблено базу даних для серверної частини «Програмної системи для контролю доступу до лабораторій». Описано прийняті інженерні рішення, розроблено UML та ER діаграми. Функції роботи з базою даних протестовані за допомогою інструменту тестування Postman. 
     Посилання на відео-захист: https://youtu.be/jAGPgP3N6C4 
     

	 

ДОДАТОК А
Скрипт на створення таблиць у БД lab_access_control




1 -- події доступу
2 CREATE TABLE IF NOT EXISTS public.accessevents
3 (
4     id integer NOT NULL DEFAULT nextval('accessevents_id_seq'::regclass),
5     user_id integer,
6     lab_id integer,
7     "timestamp" timestamp without time zone NOT NULL,
8     status character varying(100) COLLATE pg_catalog."default",
9     reason character varying(255) COLLATE pg_catalog."default",
10     CONSTRAINT accessevents_pkey PRIMARY KEY (id),
11     CONSTRAINT accessevents_lab_id_fkey FOREIGN KEY (lab_id)
12         REFERENCES public.labs (id) MATCH SIMPLE
13         ON UPDATE NO ACTION
14         ON DELETE CASCADE,
15     CONSTRAINT accessevents_user_id_fkey FOREIGN KEY (user_id)
16         REFERENCES public.users (id) MATCH SIMPLE
17         ON UPDATE NO ACTION
18         ON DELETE CASCADE,
19     CONSTRAINT chk_status CHECK (status::text = ANY (ARRAY['approved'::character varying, 'denied'::character varying   )
20 'pending'::character varying]::text[]))
21 --лабораторії
22 CREATE TABLE IF NOT EXISTS public.labs
23 (
24     id integer NOT NULL DEFAULT nextval('labs_id_seq'::regclass),
25     title character varying(255) COLLATE pg_catalog."default" NOT NULL,
26     access_requirements integer NOT NULL,
27     status_id integer,
28     CONSTRAINT labs_pkey PRIMARY KEY (id),
29     CONSTRAINT fk_status_id FOREIGN KEY (status_id)
30         REFERENCES public.labstatuses (id) MATCH SIMPLE
31         ON UPDATE NO ACTION
32         ON DELETE NO ACTION
33 )
34 --статуси лабораторій
35 CREATE TABLE IF NOT EXISTS public.labstatuses
36 (
37     id integer NOT NULL DEFAULT nextval('labstatuses_id_seq'::regclass),
38     type character varying(255) COLLATE pg_catalog."default" NOT NULL,
39     CONSTRAINT labstatuses_pkey PRIMARY KEY (id)
40 )
41 
42 --сенсори
43 CREATE TABLE IF NOT EXISTS public.sensors
44 (
45     id integer NOT NULL DEFAULT nextval('sensors_id_seq'::regclass),
46     lab_id integer,
47     type character varying(255) COLLATE pg_catalog."default" NOT NULL,
48     user_id integer,
49     "timestamp" timestamp without time zone NOT NULL,
50     access_data character varying(100) COLLATE pg_catalog."default" NOT NULL,
51     status character varying(50) COLLATE pg_catalog."default" NOT NULL DEFAULT 'active'::character varying,
52     CONSTRAINT sensors_pkey PRIMARY KEY (id),
53     CONSTRAINT sensors_lab_id_fkey FOREIGN KEY (lab_id)
54         REFERENCES public.labs (id) MATCH SIMPLE
55         ON UPDATE NO ACTION
56         ON DELETE CASCADE,
57     CONSTRAINT sensors_user_id_fkey FOREIGN KEY (user_id)
58         REFERENCES public.users (id) MATCH SIMPLE
59         ON UPDATE NO ACTION
60         ON DELETE CASCADE
61 )
62 --посади
63 CREATE TABLE IF NOT EXISTS public.useroccupations
64 (
65     id integer NOT NULL DEFAULT nextval('useroccupations_id_seq'::regclass),
66     type character varying(255) COLLATE pg_catalog."default" NOT NULL,
67     CONSTRAINT useroccupations_pkey PRIMARY KEY (id)
68 )
69 --користувачі
70 CREATE TABLE IF NOT EXISTS public.users
71 (
72     id integer NOT NULL DEFAULT nextval('users_id_seq'::regclass),
73     name character varying(255) COLLATE pg_catalog."default" NOT NULL,
74     surname character varying(255) COLLATE pg_catalog."default" NOT NULL,
75     email character varying(255) COLLATE pg_catalog."default" NOT NULL,
76     password character varying(255) COLLATE pg_catalog."default" NOT NULL,
77     access_level integer NOT NULL,
78     occupation_id integer,
79     CONSTRAINT users_pkey PRIMARY KEY (id),
80     CONSTRAINT users_email_key UNIQUE (email),
81     CONSTRAINT users_occupation_id_fkey FOREIGN KEY (occupation_id)
82         REFERENCES public.useroccupations (id) MATCH SIMPLE
83         ON UPDATE NO ACTION
84         ON DELETE NO ACTION
85 )

ДОДАТОК Б
Специфікація розробленого API
 

Перелік усіх існуючих ендпоінтів з їхнім описом наведено в таблиці 1.

     Таблиця 1 – Специфікація системи 
     «Програмна система для контролю доступу до лабораторій»
Ендпоінт 
Метод 
Опис 
/login/ 
POST 
Вхід в систему для користувачів
/logout/ 
POST 
Вихід з системи для користувачів
/users/
POST 
Реєстрація нового користувача 
/users/
GET 
Перелік усіх зареєстрованих користувачів
/users/<int:user_id>/
PUT 
Редагування інформації про користувача
/users/<int:user_id>/
DELETE 
Видалення користувача
 




Продовження табл. 1 
Ендпоінт 
Метод 
Опис 
/labs/ 
GET
Перелік усіх зареєстрованих лабораторій 
/labs/
POST
Реєстрація нової лабораторії 
/labs/<int:lab_id>/
 
PUT
Редагування інформації про лабораторію
/labs/<int:lab_id>/

DELETE
Видалення лабораторії 
/labs/<int:lab_id>/update_status/

PATCH
Оновлення статусу лабораторії 
/access_events/
GET
Список усіх створених запитів на доступ 
/access_events/
POST
Створення нового запиту на доступ
/sensors/
GET
Список усіх зареєстрованих сенсорів 







Продовження табл. 1 
/sensors/
POST 
Реєстрація нового сенсору 
/sensors/<int:sensor_id>/
DELETE 
Видалення сенсору 
 
     Було складено таблицю зі специфікацією основних ендпоінтів для серверного застосунку.
 
 
