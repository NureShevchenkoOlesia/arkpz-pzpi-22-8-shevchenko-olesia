Міністерство освіти і науки УкраїниХарківський національний університет радіоелектроніки      Звітз лабораторної роботи №3з дисципліни «Аналіз та рефакторинг коду»      Виконала: Перевірив: ст. гр. ПЗПІ-22-8 ст. викл. каф. ПІ Шевченко О. О. Сокорчук І. П.      Харків 2024 ВСТУП  	Метою лабораторної роботи є розробка бізнес-логіки та функцій адміністрування серворної частини програмної системи: «Програмна система для контролю доступу до лабораторій».      Хід даної роботи має такий вигляд:   1. Опис інженерних рішень.  1.1  Адміністрування.  1.2  Бізнес-логіка.  2. Додатки.
1 ОПИС ІНЖЕНЕРНИХ РІШЕНЬ               1.1 Адміністрування          Для даної програмної системи визначені дві групи користувачів: співробітники лабораторії та адміністратори системи. При авторизації відбувається перевірка, в процесі якої визначається відповідна роль користувача за вказаною посадою (поле «occupation_id» в табл. «Users»). Важливість даного функціонального рішення полягає в необхідності розділити функціонал, який може бути доступним різним користувачам. Відповідно, адміністрування включає:      – керування користувачами: реєстрація, редагування інформації та видалення користувачей. Співробітникам лабораторії доступний лише перегляд власного «профілю»;      – керування лабораторіями: реєстрація, редагування інформації та видалення лабораторій. Співробітникам лабораторії доступний лише перегляд списку існуючих лабораторій з метою створення запиту на отримання доступу до них;      – керування запитами: перегляд історії усіх створених запитів, генерування звітів про події доступу. Співробітникам лабораторії доступна лише власна історія запитів;      – керування сенсорами: перегляд, створення та видалення сенсорів для перевірки особи користувачів при отриманні доступу.1.3  Бізнес-логіка     Серверна частина програмної системи виконує обробку біометричних даних користувача, які використовуються для підтвердження особи при створенні запиту на отримання доступу до лабораторії. Бізнес-логіка базується на обробці цих даних (змісту сенсорів) для схвалення запиту та надання доступу співробітнику лабораторії.      Аналіз даних включає:– рівень доступу співробітника;– відповідність біометричних даних співробітника;– час створення запиту.     Для збереження інформації про запит (подію доступу) буде використано табл. «AccessEvents», для збереження інформації про сенсор первірки користувача – табл. «Sensors».      Для розрахунків використано такі математичні методи обробки даних:      – хешування паролів (з використанням алгоритму bcrypt);      – косинусна подібність для перевірки біометричних даних: біометричні дані співробітників представляються у вигляді векторів. Для перевірки відповідності даних, отриманих від сенсора, з даними, що зберігаються у базі, використовується косинусна подібність:подібність=(a ⃗b ⃗)/‖a ⃗ ‖‖b ⃗ ‖   , де      А – вектор біометричних даних з бази,      В – вектор, отриманий з сенсора.      – аналіз часових обмежень: система порівнює час створення запиту із розкладом лабораторії. Запит схвалюється, якщо час входу співробітника знаходиться у дозволеному діапазоні:access_granted = (t current ​≥ t open​) ∧ (t current​ ≤ t close​) , де          t current – час створення запиту,     t open,  t close  – час відкриття та закриття лабораторії.      	Діаграму взаємодії серверної частини програмної системи наведено на рисунку 1.Рисунок 1 – Діаграма взаємодії серверної частини програмної системи	Діаграму активності серверної частини програмної системи наведено на рисунку 2.Рисунок 2 – Діаграма активності серверної частини програмної системиВИСНОВКИ               В результаті виконання даної лабораторної роботи було розроблено бізнес-логіку та функції адміністрування серворної частини програмної системи. Створено зручний алгоритм для формування запитів на отримання доступу до лабораторій з автоматичною обробкою на основі даних про користувачів, лабораторії та сенсори для аутентифікації. Також реалізовано функції для управління інформацією про користувачів, лабораторії та події доступу. Функції адміністрування протестовані за допомогою інструменту тестування Postman.      Посилання на відео-захист: https://youtu.be/m4COB14AvQ8                     	 
ДОДАТОК ААдміністрування
# Додати нову лабораторію@labs_bp.route("/", methods=["POST"])@admin_requireddef create_lab():    try:        data = request.json        lab = Lab(            title=data["title"],            access_requirements=data["access_requirements"],            status_id=data["status_id"],        )        db.session.add(lab)        db.session.commit()        return jsonify({"message": "Lab created successfully!"}), 201    except Exception as e:        return jsonify({"error": "Failed to create lab", "details": str(e)}), 500# Оновити дані лабораторії за ID@labs_bp.route("/<int:lab_id>", methods=["PUT"])@admin_requireddef update_lab(lab_id):    try:        lab = Lab.query.get(lab_id)        if not lab:            return jsonify({"error": "Lab not found"}), 404        data = request.json        lab.title = data.get("title", lab.title)        lab.access_requirements = data.get("access_requirements", lab.access_requirements)        lab.status_id = data.get("status_id", lab.status_id)        db.session.commit()        return jsonify({"message": "Lab updated successfully!"}), 200    except Exception as e:        return jsonify({"error": "Failed to update lab", "details": str(e)}), 500# Змінити статус лабораторії@labs_bp.route("/<int:lab_id>/update_status", methods=["PATCH"])@admin_requireddef update_lab_status(lab_id):    data = request.json    lab = Lab.query.get_or_404(lab_id)    new_status = LabStatus.query.get(data["status_id"])    if not new_status:        return jsonify({"error": "Invalid status_id"}), 400    lab.status_id = data["status_id"]    db.session.commit()    return jsonify({"message": f"Lab status updated to {new_status.type}!"})# Видалити лабораторію за ID@labs_bp.route("/<int:lab_id>", methods=["DELETE"])@admin_requireddef delete_lab(lab_id):    try:        lab = Lab.query.get(lab_id)        if not lab:            return jsonify({"error": "Lab not found"}), 404        db.session.delete(lab)        db.session.commit()        return jsonify({"message": "Lab deleted successfully!"}), 200    except Exception as e:        return jsonify({"error": "Failed to delete lab", "details": str(e)}), 500# Отримати список усіх сенсорів@sensors_bp.route("/", methods=["GET"])@admin_requireddef get_sensors():    try:        sensors = Sensor.query.all()        sensors_list = [            {                "id": sensor.id,                "lab_id": sensor.lab_id,                "user_id": sensor.user_id,                "access_data": sensor.access_data,                "last_verified": sensor.timestamp,            }            for sensor in sensors        ]        return jsonify(sensors_list), 200    except Exception as e:        return jsonify({"error": "Failed to fetch sensors", "details": str(e)}), 500# Створити новий сенсор@sensors_bp.route("/", methods=["POST"])@admin_requireddef create_sensor():    try:        data = request.json        sensor = Sensor(            lab_id=data["lab_id"],            user_id=data["user_id"],            type=data["type"],            access_data=data["access_data"],        )        db.session.add(sensor)        db.session.commit()        return jsonify({"message": "Sensor created successfully!"}), 201    except Exception as e:        return jsonify({"error": "Failed to create sensor", "details": str(e)}), 500# Видалити сенсор за ID@sensors_bp.route("/<int:sensor_id>", methods=["DELETE"])@admin_requireddef delete_sensor(sensor_id):    try:        sensor = Sensor.query.get(sensor_id)        if not sensor:            return jsonify({"error": "Sensor not found"}), 404        db.session.delete(sensor)        db.session.commit()        return jsonify({"message": "Sensor deleted successfully!"}), 200    except Exception as e:        return jsonify({"error": "Failed to delete sensor", "details": str(e)}), 500# Отримати список усіх користувачів @users_bp.route("/", methods=["GET"])@admin_requireddef get_users():    try:        users = User.query.all()        users_list = [            {                "id": user.id,                "name": user.name,                "surname": user.surname,                "email": user.email,                "access_level": user.access_level,                "occupation_id": user.occupation_id,            }            for user in users        ]        return jsonify(users_list), 200    except Exception as e:        return jsonify({"error": "Failed to fetch users", "details": str(e)}), 500# Створення нового користувача @users_bp.route("/", methods=["POST"])@admin_requireddef create_user():    try:        data = request.json        hashed_password = generate_password_hash(data["password"], method="pbkdf2:sha256")        user = User(            name=data["name"],            surname=data["surname"],            email=data["email"],            password=hashed_password,  # Хешований пароль            access_level=data["access_level"],            occupation_id=data["occupation_id"],        )        db.session.add(user)        db.session.commit()        return jsonify({"message": "User created successfully!"}), 201    except Exception as e:        return jsonify({"error": "Failed to create user", "details": str(e)}), 500# Оновити дані користувача за ID@users_bp.route("/<int:user_id>", methods=["PUT"])@admin_requireddef update_user(user_id):    try:        user = User.query.get(user_id)        if not user:            return jsonify({"error": "User not found"}), 404        data = request.json        user.name = data.get("name", user.name)        user.surname = data.get("surname", user.surname)        user.email = data.get("email", user.email)        if "password" in data:            user.password = generate_password_hash(data["password"], method="pbkdf2:sha256")        db.session.commit()        return jsonify({"message": "User updated successfully!"}), 200    except Exception as e:        return jsonify({"error": "Failed to update user", "details": str(e)}), 500# Видалити користувача за ID @users_bp.route("/<int:user_id>", methods=["DELETE"])@admin_requireddef delete_user(user_id):    user = User.query.get(user_id)    if not user:        return jsonify({"message": "User not found!"}), 404    db.session.delete(user)    db.session.commit()    return jsonify({"message": "User deleted successfully!"})# Резервне копіювання бази даних@admin_bp.route("/backup", methods=["POST"])@admin_requireddef backup():    file_path = backup_database()    return jsonify({"message": "Backup created successfully!", "file": file_path}), 200# Експортує дані системи в JSON-файл@admin_bp.route("/export", methods=["GET"])@admin_requireddef export_data():    file_path = export_data_to_json()    return jsonify({"message": "Data exported successfully!", "file": file_path}), 200# Генерує звіт про події доступу@admin_bp.route("/report", methods=["GET"])@admin_requireddef generate_report():    file_path = generate_access_report()    return jsonify({"message": "Report generated successfully!", "file": file_path}), 200# Отримати всі події доступу @access_events_bp.route("/", methods=["GET"])@admin_requireddef get_access_events():    try:        events = AccessEvent.query.all()        events_list = [            {                "id": event.id,                "user_id": event.user_id,                "lab_id": event.lab_id,                "timestamp": event.timestamp,                "status": event.status,                "reason": event.reason,            }            for event in events        ]        return jsonify(events_list), 200    except Exception as e:        return jsonify({"error": "Failed to fetch access events", "details": str(e)}), 500# Створити запит після перевірки даних@access_events_bp.route("/", methods=["POST"])@login_requireddef create_access_event():    try:        data = request.json        user_id = session.get("user_id")        lab_id = data["lab_id"]        # Перевірка існування лабораторії        lab = Lab.query.get(lab_id)        if not lab:            return jsonify({"error": "Lab not found"}), 404        # Перевірка рівня доступу        user = User.query.get(user_id)        if user.access_level < lab.access_requirements:            return jsonify({"error": "Access level too low"}), 403        # Перевірка статусу лабораторії        if lab.status_id != 0:  # 0 означає "вільна"            return jsonify({"error": "Lab is not available"}), 403        # Перевірка біометричних даних через сенсор        sensor = Sensor.query.filter_by(lab_id=lab_id, user_id=user_id).first()        if not sensor:            reason = "Biometric sensor data not found"            status = "denied"        else:            reason = None            status = "approved"        # Створення події доступу        event = AccessEvent(            user_id=user_id,            lab_id=lab_id,            timestamp=datetime.utcnow(),            status=status,            reason=reason,        )        db.session.add(event)        db.session.commit()        return jsonify({"message": "Access event created", "event": {            "id": event.id,            "user_id": event.user_id,            "lab_id": event.lab_id,            "timestamp": event.timestamp,            "status": event.status,            "reason": event.reason,        }}), 201    except Exception as e:        return jsonify({"error": "Failed to create access event", "details": str(e)}), 500